//! Symmetric encryption.

use std::{fmt, io, error};
use std::io::Write;

use openssl::crypto::symm as ssl_symm;
use openssl::crypto::hmac;

use crypto::hash;

// TODO: Investigate blowfish support.
/// A symmetric cipher type.
#[allow(missing_docs, non_camel_case_types)]
#[derive(Debug, Eq, PartialEq, Clone, Copy)]
pub enum CipherType {
    AES_128_CTR,
    AES_256_CTR,
}

use self::CipherType::*;

impl CipherType {
    /// Returns this cipher type's key length in bytes.
    pub fn key_len(&self) -> usize {
        match *self {
            AES_128_CTR => 16,
            AES_256_CTR => 32,
        }
    }

    /// Returns the `openssl::crypto::symm::Type` corresponding to this type.
    fn to_openssl(&self) -> ssl_symm::Type {
        match *self {
            AES_128_CTR => ssl_symm::Type::AES_128_CTR,
            AES_256_CTR => ssl_symm::Type::AES_256_CTR,
        }
    }
}

/// An encryption mode.
#[allow(missing_docs)]
#[derive(Debug, Eq, PartialEq, Clone, Copy)]
pub enum Mode {
    Encrypt,
    Decrypt,
}

use self::Mode::*;

impl Mode {
    /// Returns the `openssl::crypto::symm::Mode` corresponding to this mode.
    fn to_openssl(&self) -> ssl_symm::Mode {
        match *self {
            Encrypt => ssl_symm::Mode::Encrypt,
            Decrypt => ssl_symm::Mode::Decrypt,
        }
    }
}

/// A symmetric cipher context.
pub struct Cipher {
    mode: Mode,
    crypter: ssl_symm::Crypter,
}

impl Cipher {
    /// Returns a new cipher for the given `mode`, `key` and `iv`
    /// (initialization vector). Returns `Error::InvalidKeyLength` if
    /// `key.len()` is not correct.
    pub fn new(ct: CipherType,
               mode: Mode,
               key: &[u8],
               iv: &[u8])
               -> Result<Cipher, Error> {
        if key.len() != ct.key_len() {
            return Err(InvalidKeyLength);
        }
        let crypter = ssl_symm::Crypter::new(ct.to_openssl());
        crypter.pad(true);
        crypter.init(mode.to_openssl(), &key[..], &iv[..]);
        Ok(Cipher {
            mode: mode,
            crypter: crypter,
        })
    }

    /// Updates the cipher, returning the encrypted/decrypted bytes.
    pub fn update(&mut self, data: &[u8]) -> Vec<u8> {
        // ssl_symm::Crypter::update actually doesn't take a mutable reference,
        // but that's sketchy, so we require mut anyway.
        self.crypter.update(data)
    }

    /// Returns this cipher's encryption mode.
    pub fn mode(&self) -> Mode {
        self.mode
    }
}

/// A combination IV, symmetric key and HMAC key generated by stretching
/// a shared secret during the secio handshake.
#[derive(Debug, Eq, PartialEq, Clone)]
pub struct StretchedKey {
    iv: Vec<u8>,
    cipher_key: Vec<u8>,
    hmac_key: Vec<u8>,
}

impl StretchedKey {
    /// Returns the streched key's initialization vector.
    pub fn iv(&self) -> &[u8] {
        &self.iv[..]
    }

    /// Returns the stretched key's cipher key.
    pub fn cipher_key(&self) -> &[u8] {
        &self.cipher_key[..]
    }

    /// Returns the stretched key's HMAC key.
    pub fn hmac_key(&self) -> &[u8] {
        &self.hmac_key[..]
    }
}


/// Stretch a shared secret into two `StretchedKey`s.
pub fn stretch_key(ct: CipherType,
                   hash_alg: hash::Algorithm,
                   secret: &[u8])
                   -> Result<(StretchedKey, StretchedKey), io::Error> {
    // Not sure if this algorithm is formally documented anywhere, I
    // adapted if from the go-ipfs source.
    let (cipher_key_size, iv_size) = match ct {
        AES_128_CTR => (16, 16),
        AES_256_CTR => (32, 16),
    };
    let hmac_key_size = 20;

    let seed = b"key expansion";
    let mut result = Vec::new();
    result.resize(2 * (iv_size + cipher_key_size + hmac_key_size), 0);

    let mut hm = hmac::HMAC::new(hash_alg.to_openssl(), secret);
    try!(hm.write(seed));

    let mut current = hm.finish();
    let mut j = 0;
    while j < result.len() {
        try!(hm.write(&current[..]));
        try!(hm.write(seed));
        let temp = hm.finish();

        let mut todo = temp.len();
        if j + todo > result.len() {
            todo = result.len() - j;
        }

        let mut mid = &mut result[j..j + todo];
        try!(mid.write(&temp[..]));

        j += todo;

        try!(hm.write(&current[..]));
        current = hm.finish();
    }

    let half = result.len() / 2;
    let k1 = &result[0..half];
    let k2 = &result[half..];

    let iv1 = k1[0..iv_size].to_vec();
    let ck1 = k1[iv_size..iv_size + cipher_key_size].to_vec();
    let hk1 = k1[iv_size + cipher_key_size..].to_vec();

    let iv2 = k2[0..iv_size].to_vec();
    let ck2 = k2[iv_size..iv_size + cipher_key_size].to_vec();
    let hk2 = k2[iv_size + cipher_key_size..].to_vec();

    let sk1 = StretchedKey {
        iv: iv1,
        cipher_key: ck1,
        hmac_key: hk1,
    };
    let sk2 = StretchedKey {
        iv: iv2,
        cipher_key: ck2,
        hmac_key: hk2,
    };

    Ok((sk1, sk2))
}

/// An error encountered during symmetric crypto operations.
#[derive(Debug, Eq, PartialEq, Clone, Copy)]
pub enum Error {
    /// An invalid key length was supplied.
    InvalidKeyLength,
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "key of invalid length provided")
    }
}

impl error::Error for Error {
    fn description(&self) -> &str {
        "key of invalid length provided"
    }

    fn cause(&self) -> Option<&error::Error> {
        None
    }
}

use self::Error::*;

#[cfg(test)]
mod tests {
    use super::*;
    use crypto::hash;

    #[test]
    fn test_encrypt_decrypt() {
        let mut enc = Cipher::new(CipherType::AES_256_CTR,
                                  Mode::Encrypt,
                                  b"secret key1111111111111111111111",
                                  b"iv")
                          .unwrap();
        let mut dec = Cipher::new(CipherType::AES_256_CTR,
                                  Mode::Decrypt,
                                  b"secret key1111111111111111111111",
                                  b"iv")
                          .unwrap();
        assert_eq!(enc.mode(), Mode::Encrypt);
        assert_eq!(dec.mode(), Mode::Decrypt);
        let buf = enc.update(b"a secret message here");
        assert_eq!(&dec.update(&buf[..])[..], b"a secret message here");
    }

    #[test]
    fn test_invalid_key_length() {
        assert!(Cipher::new(CipherType::AES_256_CTR,
                            Mode::Encrypt,
                            b"too short",
                            b"iv")
                    .is_err());
    }

    #[test]
    fn test_stretch_key() {
        // These example stretched keys were generated using go-ipfs.
        let sk1 = StretchedKey {
            iv: vec![0x81, 0xa1, 0x18, 0x8f, 0xd4, 0x42, 0xf, 0x36, 0x2a,
                     0xe8, 0x9c, 0xb3, 0xde, 0xc8, 0x37, 0xbe],
            hmac_key: vec![0x26, 0x77, 0xef, 0x34, 0x96, 0x4f, 0xe6, 0x4a,
                           0xa3, 0x7d, 0xe1, 0x51, 0x85, 0x9, 0x54, 0x3f,
                           0x17, 0xdc, 0x95, 0x70],
            cipher_key: vec![0xe4, 0xd6, 0xeb, 0xb8, 0xda, 0xc2, 0x50, 0x84,
                             0x45, 0x97, 0x5b, 0xdd, 0xf4, 0xc4, 0xc9, 0x72,
                             0xfe, 0x2f, 0xba, 0x85, 0xd, 0xc0, 0x38, 0xc9,
                             0xa1, 0xf5, 0x5c, 0x70, 0x4e, 0x84, 0xd2, 0x6a],
        };
        let sk2 = StretchedKey {
            iv: vec![0xcb, 0x70, 0x40, 0xd6, 0x28, 0x68, 0xb8, 0x5, 0x6a,
                     0x60, 0x16, 0x1c, 0xe9, 0x4c, 0xa1, 0x75],
            hmac_key: vec![0xc0, 0xca, 0xac, 0xea, 0x3a, 0x9a, 0x72, 0x58,
                           0x83, 0xd8, 0x7a, 0xae, 0xe4, 0x2e, 0x87, 0xcc,
                           0xb4, 0x5a, 0x64, 0xe2],
            cipher_key: vec![0x57, 0xf2, 0xe2, 0x7d, 0xf, 0xff, 0xab, 0x3c,
                             0x57, 0x40, 0x90, 0x36, 0x5f, 0x4b, 0x79, 0xa1,
                             0xea, 0xe5, 0x50, 0x19, 0xe, 0x33, 0xfc, 0x14,
                             0xb9, 0x4f, 0x1a, 0x10, 0x55, 0x8b, 0xa3, 0x9],
        };

        assert_eq!(stretch_key(CipherType::AES_256_CTR,
                               hash::Algorithm::SHA256,
                               b"secret")
                       .unwrap(),
                   (sk1, sk2));
    }

}
